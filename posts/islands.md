---
title: "Задача про острова"
date: "2021-03-18"
---

Всем привет! Сейчас мы рассмотрим задачу, которая называется поиск островов.

```jsx
const graph = [
  [ 0, 1, 0, 1, 0, 0, 0 ],
  [ 0, 1, 1, 1, 0, 0, 0 ],
  [ 0, 0, 1, 0, 0, 1, 1 ],
  [ 1, 1, 0, 0, 1, 1, 0 ],
  [ 1, 1, 1, 0, 1, 1, 0 ],
  [ 0, 1, 1, 0, 1, 0, 0 ],
  [ 0, 1, 0, 0, 0, 0, 1 ],
]
```

У нас есть двумерный массив нулей и единичек. Островами называются группы связанных единиц - то есть таких, у которых есть сосед по вертикали или горизонтали из этой же группы. В нашем случае массив содержит 4 острова

Нажмите на паузу и попытайтесь решить самостоятельно.

У каждой единички может быть до 4 соседей - сверху, снизу, справа и слева.

Задачу можно решить с помощью обхода в глубину. То есть мы будем делать некое действие над клеткой, которую мы передаем в качестве аргумента функции, а затем последовательно вызываем саму себя над соседями. Причем получается, что пока мы не пройдем все клетки, ведущие от одного соседа, не перейдем к следующему.

```jsx
const dfs = (i, j) => {
    if (i < 0 || i >= rows) return
    if (j < 0 || j >= cols) return
    if (!graph[i][j]) return
    
		graph[i][j] = 0
    dfs(i + 1, j)
    dfs(i - 1, j)
    dfs(i, j + 1)
    dfs(i, j - 1)
  }
```

Вернемся к основной задаче.

Будем перебирать все клетки с помощью двойного цикла по номеру строки и по номеру столбца. Двигаемся до тех пор, пока не наткнемся на единицу, это будет наша точка входа на остров. Начинаем его исследовать. Вызываем алгоритм поиска в глубину, который будет обнулять посещенные клетки. Этот прием позволяет нам не запоминать клетки, куда ступала нога алгоритма - поскольку там уже не будет острова. Количество инициаций алгоритма даст нам искомое количество островов.

```jsx
const islands = (graph) => {
  const rows = graph.length
  const cols = graph[0].length
  let count = 0

  const dfs = (i, j) => {
    if (i < 0 || i >= rows) return
    if (j < 0 || j >= cols) return
    if (!graph[i][j]) return
    
		graph[i][j] = 0
    dfs(i + 1, j)
    dfs(i - 1, j)
    dfs(i, j + 1)
    dfs(i, j - 1)
  }

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (graph[i][j]) {
				count++
				dfs(i, j)
    }
  }
  return count
}
```

Вместо поиска в глубину можно применить поиск в ширину, который будет работать похожим образом, но намного надежнее, поскольку не будет рекурсий.

Опять проходим по всем клеткам двойным циклом. Как только наткнёмся на единичку, помещаем ее в очередь и запускаем наш алгоритм поиска в ширину. Этот алгоритм вытаскивает из головы очереди клетку. Зануляет её. Смотрит, есть ли у нее единички-соседи, и добавляет их в очередь. Когда вынимать из очереди уже нечего, значит мы побывали во всех клетках острова. Количество таких вызовов опять даст нам количество островов.

```jsx
const islands = (graph) => {
  const rows = graph.length
  const cols = graph[0].length
  let count = 0

	const bfs = () => {
	  const q = [ [ i, j ] ]
	
	  while (q.length) {
	    const [ a, b ] = q.shift()
	    graph[a][b] = 0
	    if (graph[a][b + 1]) q.push([ a, b + 1 ])
	    if (graph[a][b - 1]) q.push([ a, b - 1 ])
	    if (graph[a + 1]?.[b]) q.push([ a + 1, b ])
	    if (graph[a - 1]?.[b]) q.push([ a - 1, b ])
	  }
	}
  for (let i = 0; i < rows; i++)
    for (let j = 0; j < cols; j++)
      if (graph[i][j] === 1) {
        count++
        bfs()
      }
  return count
}
```

Это пример работы нашего алгоритма. Коричневым цветом помечаются клетки, которые хранятся в очереди, а зеленые - уже изъятые из очереди.

На этом все.