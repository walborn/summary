---
title: "Вычисление чисел Фибоначчи"
date: "2020-12-02"
---

## Немного истории

Эти числа ввёл в 1202 г. Фибоначчи (Fibonacci 1170г рождения). Настоящее имя Леонардо Пизанский (Leonardo Pisano). А прозвище Фибоначчи он получил уже после своей смерти. Fibonacci - это производная от слов filius Bonacci, то есть сын Боначчи, а может, удачливый сын, если дословно перевести. Название последовательности в том виде, как мы ее знаем, получило благодаря математику 19 века Люка (Lucas)

Впрочем, индийские математики упоминали числа этой последовательности ещё раньше: Гопала (Gopala) до 1135 г., Хемачандра (Hemachandra) — в 1150 г.

## Теория

Числа Фибоначчи - это последовательность, первые два числа которой 0 и 1, а дальше каждое следующее - это сумма двух предыдущих

0  1  →  0  1  (0+1)  → 0 1  1  → 0 1  1  (1+1) → 0 1 1 2

### Точная формула

Существует точная формула числа Фибоначчи

```jsx
const fib = n => (((1 + 5 ** .5)/2)**n - ((1 - 5**.5)/2)**n) / 5**.5
```

Эту формулу вывел Бине (Binet). Доказать ее можно индукцией. Попробуйте самостоятельно это сделать. Мы же просто ее проанализируем.

Можно увидеть, что второй член по модулю равен примерно `0.62 ** n`. Его можно отбросить, поскольку при делении на корень из 5 он меньше 0.5, особенно, при больших n, а значит не отклоняет решение от точного при округлении до ближайшего целого.

```jsx
const fib = n => Math.round(((1 + 5 ** .5)/2)**n / 5**.5)
```

Она дает верный результат до `n = 70`, а дальше компилятору уже не будет хватать вычислительной точности. 

```jsx
fib(71) 308061521170130 ≠ F[71] 308061521170129
```

### Рекурсия

Попробуем решить в лоб

Мы знаем, что числа Фибоначчи задаются следующей рекуррентной формулой:

```jsx
F[0] = 0
F[1] = 1
F[n] = F[n-1] + F[n-2]
```

Напрашивается рекурсия

```jsx
const fib = n => {
	if (n < 2) return n
	return fib(n-1) + fib(n-2)
}

// or
const fib = n => n < 2 ? n : fib(n-1) + fib(n-2)
```

Конечно же, если пользователь введет не целое число или отрицательное, то результат будет сомнительный. Но программисты - народ ленивый, а я еще ленивей, поэтому я не буду делать проверку. Но никогда не делайте так в реальных проектах!

Давайте попробуем оценить вычислительную сложность алгоритма

```jsx
T(n) = T(n-1) + T(n-2) + O(1)
T(n-2) + T(n-2) < T(n) < T(n-1) + T(n-1)
2 * T(n-2) < T(n) < 2 * T(n-1)
T(n) = 2 * T(n-1) - следует, что T(n) < 2**n = O(2**n)
T(n) = 2 * T(n-2) - следует, что T(n) > 2**(n/2) = O(1.41**n)

На самом деле можно оценить еще точнее. Вы, наверное, заметили,
что оценка времени вычисления формулы Фибоначчи задается самой же
этой формулой. А мы знаем точное решение. Таким образом θ(n) = 1.62**n

Второй подход даст нам очень грубое ограничение сверху.
Предположим, что T(n) = O(2**n). Тогда
T(n) = O(2 ** (n-1)) + O(2 * (n-2)) + O(1) = O(2**n)
Получается, что сложность O(2**n)
Но жесткой асимптотой является сама же функция Фибоначчи,
то есть T(n) = O(F(n))
```

Наше решение прекрасно, но на больших `n` оно о-о-очень медленное. Для `n = 50` было уже не дождаться ответа

fib(47) = 12586269025

И, как мы помним, сложность равна тому, чему равно это число. То есть если у нас одно вычисление происходит одну миллисекунду, то 12586269025 ms =  12586269 s = 145 days

А fib(100) будет вообще вычисляться до тепловой смерти вселенной, хотя любой может его найти, используя только ручку и листок бумаги.

Можно ли улучшить этот метод? Да, можно!

Заметим, что мы повторяем одни и те же вычисления.

fib(n) = fib(n-1) + fib(n-2) = **fib(n-2)** + fib(n-3) + **fib(n-2)**

А что, если запоминать уже вычисленные решения. Перепишем нашу рекурсию

```jsx
const x = [ 1, 1 ]
const fib = n => {
	if (x[n]) return x[n]
	return x[n] = fib(n-1) + fib(n-2)
}

// or
const fib = n => x[n] || (x[n] = fib(n-1) + fib(n-2))
```

Поскольку в результате получается массив `x`, который содержит все числа Фибоначчи до `n`, и каждое число вычисляется только один раз, то сложность алгоритма теперь линейная - `O(n)`

### Итерационный

Но мы же знаем, что если вычислять Фибоначчи по-человечески, то есть последовательно, одно число за другим, то, во-первых, это будет сильно быстрее рекурсивного решения, а, во-вторых, проще, чем метод с запоминанием.

В коде это будет выглядеть так

```jsx
const fib = n => {
	let [ a, b ] = [ 0, 1 ]
	for (let _ = 0; _ < n; _++) [ a, b ] = [ b, a + b ]
	return a
}
```

### Матричный

Но есть еще быстрее способ, не за линейное, а за логарифмическое время. В этом нам поможет матричная запись формулы Фибоначчи и умение брать степень за логарифмическое время.

```jsx
F[n]       =  1  1   x    F[n - 1]   =   1 1  ** n   x    1
F[n - 1]      1  0        F[n - 2]       1 0              0
```

```jsx
const x = ([ a, b, c, d ], [ x, y, z, t ]) => [
    a*x + c*y, b*x + d*y,
    a*z + c*t, b*z + d*t,
]

const fib = n => (function fn(n) {
  if (n === 1) return [ 1, 1, 1, 0 ]
  const [ a, b, c, d ] = (A => x(A, A))(fn(n >> 1))
  return n % 2
    ? [ a + c, b + d, a, b ]
    : [ a, b, c, d ]
})(n)[0]
```

```jsx
// | a c |  x | x z | = | ax + cy   az + ct |
// | b d |    | y t |   | bx + dy   bz + dt |
const x = ([ a, b, c, d ], [ x, y, z, t ]) => [ a*x + c*y, b*x + d*y, a*z + c*t, b*z + d*t ]

const N = (n) => {
	if (n === 1) return [ 1, 1, 1, 0 ]
	const H = N(n>>1) // целочисленное деление на 2
	const T = times(H, H)
	return n % 2 ? times(T, [ 1, 1, 1, 0 ]) : T
}

const fib = (n) => {
	const [ a, b ] = N(n)
	return a + b
}

const delay = (f, ...args) => {
	const start = Date.now()
	for (let i = 0; i < 10000; i++) f(...args)
	return Date.now() - start
}

console.log(delay(fib, 5000))

// or
const square = ([ a, b, c, d ]) => [ a*a + c*b, b*a + d*b, a*c + c*d, b*c + d*d ]

const M = (n) => {
	if (n === 1) return [ 1, 1, 1, 0 ]
	const T = square(M(n>>1))
	return n % 2 ? [ T[0] + T[2], T[1] + T[3], T[0], T[1] ] : T
}

fib = (n) => (([ a, b ]) => a + b)(M(n))

const delay = (f, ...args) => {
	const start = Date.now()
	for (let i = 0; i < 100000; i++) f(...args)
	return Date.now() - start
}

delay(fib, 50000) // 124

// compare with iterative method
fib = n => {
	let [ a, b ] = [ 0, 1 ]
	for (let _ = 0; _ < n; _++) [ a, b ] = [ b, a + b ]
	return a
}
delay(fib, 50000) // 7102
```

Время выполнения у нас определяется тем, как быстро мы вычисляем `n`-ю степень матрицы `[ 1, 1, 1, 0 ]`. Это можно сделать за время `O(log(n))`, поскольку если

1.  `n = 2 * x`, то нужно вычислить матрицу в степени `n/2`, а затем возвести её в квадрат
2. `n = 2 * x + 1`, то делаем то же самое, но еще умножаем на базовую матрицу `[ 1, 1, 1, 0 ]`

То есть мы делаем либо 2, либо 3 умножения матриц за шаг

## Замечания

В задачах часто встречается, что нужно найти число Фибоначчи по модулю, поскольку для больших n получаются очень длинные числа, которые не каждый язык может хранить в числовом виде.

## Природа

1. Некоторые растения содержат в себе числа Фибоначчи, например, тысячелистник растёт как дерево Фибоначчи. От основной ветки на равном расстоянии х отходит дочерняя ветка, которая начинает разветвляться только через 2х от корня, а дальше тоже через каждые х
2. Сам Фибоначчи предлагал задачу с кроликами. Которая звучит в современной переделке примерно так:
Ученые поместили двух кроликов в кроличий рай. Кролики, как только им исполнится два месяца, начинают рожать каждый месяц двух крольчат. Сколько пар кроликов будет через 60 месяцев?